# Чтение текстового ввода: недостаток, снижающий популярность C# и .NET

На [контестах](https://codeforces.com) по программированию, собеседованиях, или при решении задач из [архивов](https://timus.online/?locale=ru) для прокачки знаний про алгоритмам мы сталкиваемся с автоматическими проверяющими системами. Эти системы принимают код на одном из поддерживаемых языков программирования, затем компилируют его и запускают на множестве различных вводов (тест-кейсов).

Несмотря на то, что современные версии C# обычно поддерживаются в таких системах, я предпочитаю использовать C++, Java или Kotlin для решения алгоритмических задач. Почему? Потому что проверяющие системы подают тестовые данные в виде текста на STDIN (стандартный ввод) и в C# нет хорошего способа прочитать и распарсить их.

## The Недостаток

Разберём пример. Это ["A+B problem"](https://timus.online/problem.aspx?space=1&num=1000&locale=ru), простая задача, позволяющая освоиться с проверяющей системой.
```plain
Условие:
Вычислите A + B (|A|, |B| <= 10^5)

Ввод:
Одна строка, содержащая два целых числа, A и B, разделённые одним пробелом

Вывод:
Значение A+B

Замечания:
Используйте +
```

Всё просто, не так ли?

Сравним решения этой задачи на разных языках програмимрования.

#### C:
```c
#include <stdio.h>

int main()
{
    int a, b;
    scanf("%d %d", &a, &b);
    printf("%d", a + b);
}
```

#### C++:
```c++
#include <iostream>
using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    cout << a + b;
}
```

#### Kotlin (код Java похож, но гораздо длиннее):
```kt
import java.util.*

fun main() {
    val sc = Scanner(System.`in`)
    val a = sc.nextInt()
    val b = sc.nextInt()
    print(a + b)
}
```

#### C# с включенными [Top-level statements](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements) и [Global usings](https://blog.jetbrains.com/dotnet/2021/11/18/global-usings-in-csharp-10/):
```csharp
var numbers = Console.ReadLine().Split();
var a = int.Parse(numbers[0]);
var b = int.Parse(numbers[1]);
Console.WriteLine(a + b);
```

#### Или однострочником на C#:
```csharp
Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());
```

Как можно видеть, решения на C, C++ и Kotlin просто читают два целых числа из ввода. Программа на C# же должна вначале прочитать одну строку с помощью `.ReadLine()`, затем разбить её через `.Split()` по пробельным символам, затем распарсить (`.Parse`) каждую часть этой строки в число типа `int`.

Т.е. когда во многих других ЯП можно читать ввод как последовательность токенов разных типов, в C# приходится читать ввод либо посимвольно, либо строками, и лишь затем вручную парсить его в нужные типы данных. Простой абстракции, которая скрывала бы эту излишнюю сложность от программиста в .NET нет.

Лично я предпочитаю решение на C++ для этой задачи, потому что код в методе `main` гораздо короче, чем на других языках — всего 32 символа, если не считать необязательные пробелы, также это решение достаточно простое для чтения. Для сравнения, однострочник на C# содержит 70 символов. Для настоящих же, не демо задач, C++ часто гораздо сложнее в отладке.

## Почему ручной парсинг — проблема?

### Устойчивость к изменениям формата
Вернёмся к задаче "A+B problem" и изменим формат ввода.

```diff    
Ввод:
- Одна строка, содержащая два целых числа, A и B, разделённые одним пробелом
+ Две строки, каждая содержит одно целое число
```

Решения на C, C++ и Kotlin останутся без изменений. Но решение на C# придётся переписать для поддержки нового формата ввода.

```csharp
Console.WriteLine(int.Parse(Console.ReadLine()) + int.Parse(Console.ReadLine()));
```

В этом простом случае можно написать решение на C#, поддерживающее оба формата ввода используя метод `Console.ReadToEnd()`, но это слишком неудобно, когда ввод более сложный.


### Сложность для восприятия
При решении влгоритмических задач вы хотите концентрироваться на алгоритмах, корректности реализации, но не на форматах ввода, обработке концов строк, невидимых [пробелах в Unicode](https://en.wikipedia.org/wiki/Whitespace_character) и других нюансах. Гораздо проще, когда всё это обрабатывается заранее написанным кодом, в идеальном случае — кодом из стандартной библиотеки.

Также, на контестах требуется экономить время, т.к. скорость решения задач влияет на финальный счёт. 

### Производительность
Очевидно, строка `int.Parse(Console.ReadLine())`, аллоцирует промежуточный объект `string`. Это занимает время и требует выделение памяти. Далее, если сработает сборщик мусора, он также потратит время на обработку и удаление этого объекта.

Если строка содержит более одного токена, промежуточный массив `int[]` будет аллоцирован внутри метода `.Split()`, с аналогичными последствиями.

Также есть и другие проблемы с производительностью текстового ввода-вывода, о которых пойдёт речь в следующих постах.

## Недооценка проблемы

Этот недостаток присущ не только языку C# и платформе .NET. Например, в Python и Rust и других языках используется такой же подход для чтения текстового ввода. И это далеко не недостаток при повседневном энтерпрайз-использовании ЯП, т.к. вместо текстового ввода обычно используются JSON'ы и прочие структурированные форматы данных.

Для консольных приложений можно использовать [System.CommandLine](https://learn.microsoft.com/en-us/dotnet/standard/commandline/) и другие библиотеки для парсинга аргументов и ввода. Но проверяющие системы ограничивают до возможностей стандартной библиотеки и стандартизированного формата ввода — там нельзя просто взять и установить внешнюю зависимость, например из NuGet.

Но почему это важно?
 - Решение алгоритмических задач и участие в контестах — отличные способы изучить новые вещи и прокачаться как программист. Возможность без лишних проблем использовать хорошо знакомый ЯП значительно упрощает это, особенно для начинающих.
 - Эта фича позволит продвигать язык как средство для решения алгоритмических задач в системах с автоматической проверкой.
 - Для начинающих изучать программирование с помощью решения алгоритмических задач, это позволит выбрать C# и .NET вместо других языка и платформы.

## Что делать?

Уже есть [.NET API Proposal](https://github.com/dotnet/runtime/issues/64621), описывающий эту проблему. Этот proposal далёк от идеала, но там уже обсуждались потребности в этой фиче и варианты реализации. Скорее всего, если эта фича дойдёт до реализации, это будет похоже на класс `Scanner` из Java.

Если вы тоже считаете эту фичу полезной — пожалуйста, поставьте палец вверх на GitHub!

## Анонс
В следующих постах я расскажу о:
 - Проблемах с производительностью текстового ввода-вывода
 - Вариантах реализации оптимального и удобного текстового ввода-вывода
